#!/usr/bin/ruby
#OBake version 0.2

#add the cliawesome code to the runtime path
#$: << 'lib/cliawesome'

require 'rubygems'


require "set"
require "fileutils"
require "pathname"

require File.expand_path('../lib/cliawesome/configmanager.rb', __FILE__)

$DEBUG = false

def debug(str)
	puts str if $DEBUG
end

class OBaker

	@@clean = :clean
	@@compiler = :compiler
	@@machineCodeCompiler = :machine
	@@byteCodeCompiler = :byte

	@@executables = :executables
	@@profiling = :profiling
	@@byteImpls = :byteImpls
	@@appSummary = "OBake is a Bare-minimum build tool for Ocaml that is not" + 
			" make."

	@@sourceDir = :sourcesDir
	@@buildDir = :buildDir
	@@binDir = :binDir 
	@@linkLibraries = :linkLibraries


	def OBaker.getConfigDef() 
		clManager = CommandLineManager.new()
		yamlManager = CrawlUpConfigFile.new("obake.yml")
		optConf = ConfigDef.new("OBake", @@appSummary, clManager, yamlManager)
		
		#compiler option
		compilerDef = SwitchDef.new(@@compiler, "Compiler Mode", 
			"Ocaml can compile to machine code or byte code. The two are " +
			"functionally equivalent at both compile time and runtime, but " +
			"byte code is faster to compile and slower at runtime. Has no " +
			"real effect when compiling .mli (header) files.")
		compilerDef.addCase(@@machineCodeCompiler, "m", "machine-code", 
				"Compile all files to machine code using ocamlopt")
		compilerDef.addCase(@@byteCodeCompiler, "b", "byte-code", 
				"Compile all files to byte code using ocamlc. This is the default.")
		compilerDef.setDefault(@@byteCodeCompiler)
		optConf.addFlagDef(compilerDef)


		#build executables? option
		binDef = SwitchDef.new(@@executables, "Build Executables",
			"OBake can build executables by deducing exactly which modules " +
			"are needed to link the  target source files' compiled version " +
			"and then perform the linking step. Executables are given extension " +
			".bin and placed in the binDir defined in the config file." )
		binDef.addCase(:yes, "e", "executable", 
				"Build executables for the input filenames")
		#binDef.addCase(false, "ne", "no-executables", 
		#		"Only compile the files independently, don't link. This is default")
		#binDef.setDefault(false)
		binDef.setCommandLineOnly()
		optConf.addFlagDef(binDef)

		#clean option
		cleanDef = SwitchDef.new(@@clean, "Clean",
			"Delete contents of buildDir and binDir before doing any compilation." +
			" Can be used independently of compiling operations, that is " +
			" \">obake -c myFile.ml\" will clear the output directories and then " +
			"compile myFile.ml, while \">obake -c\" will simply clear the output" +
			" directories and quit.")
		cleanDef.addCase(:yes, "c", "clean", 
				"Clean before proceeding to compilation.")
		#cleanDef.addCase(false, "nc", "no-clean", 
		#		"Do not clean, just overwrite changed files. This is default")
		cleanDef.setCommandLineOnly()
		#cleanDef.setDefault(false)
		optConf.addFlagDef(cleanDef)

		#used when trying to guess that the current directory is the 
		#project directory when generating config files
		pwd = FileUtils.pwd()

		#enable profiler
		profilerDef = SwitchDef.new(@@profiling, "Enable Profiling",
			"Enable profiling of executables. All files will need to be" +
			" recompiled, as well as the linking step. Running the exec" +
			" will then generate a dump file, which can be viewed with " +
			" gprof or XXX. Only affects machine-code compiled files." )
		profilerDef.addCase(:yes, "p", "profiling", 
				"Enable executables to be analyzed by a profiler.")
		profilerDef.setCommandLineOnly()
		optConf.addFlagDef(profilerDef)

		#sources dir option
		sourceDirDef = ValueDef.new(@@sourceDir, "Sources Directory", "src",
			"sources-directory", 1, 
			"The root directory of where the project sources are. While the " +
			"specific files to compile will be given as arguments on the command" +
			"line, the location of all source files to consider is necessary to " +
			"auto-detect dependencies.")
		sourceDirDef.setConfigFileOnly()
		sourceDirDef.setIsMandatory(true)
		sourceDirDef.setValueDocLabels([(pwd + '/src/')])
		optConf.addFlagDef(sourceDirDef)

		#build dir option
		buildDirDef = ValueDef.new(@@buildDir, "Build Directory", "bld",
			"build-directory", 1, 
			"The directory where files generated by obake will be output to. " +
			"This includes .ml and .mli files genrated by the lexer and parser" +
			" but not executable .bin files.")
		buildDirDef.setConfigFileOnly()
		buildDirDef.setIsMandatory(true)
		buildDirDef.setValueDocLabels([(pwd + '/build/')])
		optConf.addFlagDef(buildDirDef)

		#bin dir option
		binDirDef = ValueDef.new(@@binDir, "Executables Directory", "exd",
			"executables-directory", 1, 
			("The directory where files linked into executables by obake will be" +
			"output to. "))
		binDirDef.setConfigFileOnly()
		binDirDef.setIsMandatory(true)
		binDirDef.setValueDocLabels([(pwd + '/bin/')])
		optConf.addFlagDef(binDirDef)
		
		#bin dir option
		linkLibrariesDef = ValueDef.new(@@linkLibraries, "Libraries", "libs",
			"libraries-for-executables", 1, 
			("A list of ocamlfind package names to include in the compilation." +
			" Valid values can be found by the command'>ocamlfind list'"))
		linkLibrariesDef.setConfigFileOnly()
		linkLibrariesDef.setIsMandatory(false)
		linkLibrariesDef.setValueDocLabels(["lablgtk2"])
		optConf.addFlagDef(linkLibrariesDef)

		#require cmo's for byte code comp optio
		byteImplsDef = SwitchDef.new(@@byteImpls, "Force ByteCode Impl Files",
			"When compiling byte code files, the default is to only require" +
			"cmi (compiled headers) of dependencies to be present. This will " +
			"force the cmo (compiled impls) of dependency modules to be " +
			"built. This is turned on automatically when building byte code " +
			"executables.")
		byteImplsDef.addCase(:yes, "o", "force-cmos", 
			"Force implementation (cmo) dependencies for byte code comp.")
			byteImplsDef.setCommandLineOnly()
		optConf.addFlagDef(byteImplsDef)


		return optConf
	end

	#resolve relative paths relative to the ocaml project root, which is
	#where the ocaml config file lives. just returns the value if
	#it an absolute path
	def resolvePath(possiblyRelativePath, rootDir)
		path = Pathname.new(possiblyRelativePath)
		if(path.absolute?()) then
			return path.to_s()
		else
			rootPath = Pathname.new(rootDir)
			return rootPath.join(path)
		end
	end
	
	#initialized with a Hash of OptionKeys => OptionValues as defined by
	#the ConfigDef of Obaker.getConfigDef
	def initialize(configDef)
		optsHash = configDef.getArgumentHash()
		projectBaseDir = File.dirname(configDef.yaml_manager().getPathname())
		@compiler = optsHash[@@compiler]
		@buildExecutables = (optsHash[@@executables] == :yes)
		@profilingEnabled =  (optsHash[@@profiling] == :yes)
		@useByteImpls = ((@compiler == @@byteCodeCompiler) && 
			((optsHash[@@byteImpls] == :yes) || @buildExecutables))
		@mainTargets = configDef.getOpenList()

		@srcsLocation = resolvePath(optsHash[@@sourceDir][0], projectBaseDir)
		@buildDestination = resolvePath(optsHash[@@buildDir][0], projectBaseDir)
		Dir.mkdir(@buildDestination) unless File.exists?(@buildDestination)
		@binDestination = resolvePath(optsHash[@@binDir][0], projectBaseDir)
		Dir.mkdir(@binDestination) unless File.exists?(@binDestination)

		includeDirs = Dir.glob("#{@srcsLocation}/**/") << @buildDestination
		@includesString = makeIncludesString(includeDirs)
		#debug @includesString

		@parserFiles = (Dir.glob("#{@srcsLocation}/**/*.mly")).map do |fn|
				File.expand_path(fn)
			end
		@lexerFiles = (Dir.glob("#{@srcsLocation}/**/*.mll")).map do |fn|
				File.expand_path(fn)
			end

		@clean = (optsHash[@@clean] == :yes)

		@libraries = optsHash[@@linkLibraries]
		@libsStr = makeLibsStr(@libraries)


	end

	#calc the dependencies and do all the compilations
	def bake()
		debug "Bake Start: #{arrayString(Process.times)}"
		if(@clean)
			FileUtils.rm_r Dir.glob("#{@buildDestination}/*")
			if(@mainTargets.empty?())
				#nothing was supposed to be compiled, we'll just abort here
				exit
			end
		end
		debug "Bake Start Lex: #{arrayString(Process.times)}"
		runLexers()
		runParsers()

		debug "Bake Start Maintargets: #{arrayString(Process.times)}"
		#the roots of the dependency graph, the targets we were told to build
		rootSet = Set.new()
		@mainTargets.each do |src| 
			#ignore all but .ml and .mli files. 
			if(['.ml', '.mli'].any? {|ext| File.extname(src) == ext})
				rootSet << sourceToTarget(File.expand_path(src))
			end

		end
		debug "\nMain Targets:"
		debug setString(rootSet)

		debug "Bake Start Dependencies: #{arrayString(Process.times)}"
		#every key is a target filename, and it's value is an array of files it
		#depends on. leafSet are those targets with no dependencies
		dependencyHash, leafSet = calcDependencies(rootSet)
		debug "\nDependencies:"
		debug setHashString(dependencyHash)

		debug "\nLeaf Targets:"
		debug setString(leafSet)

		debug "Bake Start Invert Dep: #{arrayString(Process.times)}"
		#every key is a filename, and it's value is an array of files that
		#require it to be built before it can be built
		neededByHash = invertDependencies(dependencyHash)
		#this will make traversing over the graph have more elegant end cases
		rootSet.each do |t| 
			unless (neededByHash.has_key?(t))
				neededByHash[t] = Set.new()
			end
		end

		debug "\nDependents:"
		debug setHashString(neededByHash)
		
		debug "Bake Start Ordering: #{arrayString(Process.times)}"

		masterOrdering = findOrdering(neededByHash, leafSet)
		debug "\nOrdering:"
		debug arrayString(masterOrdering)

		#determine the set of files that are stale, or are dependent on stale
		#files
		debug "Bake Start Stale: #{arrayString(Process.times)}"
		staleSet = findStaleTargets(neededByHash, dependencyHash, leafSet)
		puts "\nStale Targets:"
		puts setString(staleSet) + "\n"

		debug "Bake Start Compile: #{arrayString(Process.times)}"
		debug "\nStart Compiling"
		compileSources(masterOrdering, staleSet)
		debug "Done Compiling"
		debug "buildExecutables: \'#{@buildExecutables}\'"
		if(@buildExecutables) 
			debug "\nBuilding Executables"
			binSourceSet = Set.new()
			@mainTargets.each do |src| 
				#ignore all but .ml  files. 
				if(File.extname(src) == ".ml")
					debug "Queueing: #{src}"
					binSourceSet.add(File.expand_path(src))
				end
			end
			buildExecs(binSourceSet, masterOrdering, dependencyHash, staleSet)
		end
		debug "Bake End: #{arrayString(Process.times)}"
	end

	#for every file that needs to be compiled, determine what files are
	#necessary to build it. rootTargets are Target filenames that are
	#the final files to be built
	def calcDependencies(rootTargets)
		#(k,v) = (targetFilename, Set(neededTarget1, ... neededTargetN))
		dependencyHash = Hash.new()

		leafSet = Set.new()

		#targetFilenames that are part of some other target's dependencies, 
		#but not yet visited and had their own dependencies added to dependencyHash
		#initialize to the main targets
		pendingTargets = Array.new()
		pendingTargets.concat(rootTargets.to_a)

		until (pendingTargets.empty?)
			target = pendingTargets.pop()
			deps = calcImmediateDependencies(target)
			dependencyHash[target] = deps
			if(deps.empty?)
				leafSet << target
			else
				deps.each do |dep|
					unless(pendingTargets.include?(dep) || 
							dependencyHash.has_key?(dep))
						pendingTargets.push(dep)
					end
				end
			end
		end

		return [dependencyHash, leafSet]
	end

	#given a name of a source file to compile, returns the name of the
	#desired target filename, still in the sources directory
	def sourceToTarget(source_file)
		src_ext = File.extname source_file
		targ_ext = case src_ext
			when '.mli' 
				'.cmi'
			when '.ml' 
				case @compiler 
					when @@byteCodeCompiler
						'.cmo'
					when @@machineCodeCompiler
						'.cmx'
				end
			else 
				puts "ERROR couldn't deduce dependency ext: " + source_file
				return 'ERROR'
		end
		return changeExt(source_file, targ_ext)
	end

	#given the name of a target file, return the source file that would be
	#compiled to generate that target
	def targetToSource(target_file)
		target_ext = File.extname(target_file)
		source_ext = case target_ext
			when '.cmo' then '.ml'
			when '.cmx' then '.ml'
			when '.cmi' then '.mli'
			else puts "ERROR couldn't deduce dependency ext: " + target_ext
		end
		return changeExt(target_file, source_ext)
	end

	#uses ocamldep to find primary dependencies (first level deps)
	#returns an array of strings, where members are the files the target depends on
	def calcImmediateDependencies(target_file)
		src_file = targetToSource(target_file)
		depstr = case @compiler
			when @@byteCodeCompiler 
				`ocamldep #{@includesString} #{src_file}` 
			when @@machineCodeCompiler
				`ocamldep -native #{@includesString} #{src_file}` 
			else 
				puts "ERROR couldn't compile to file: " + target
		end
		#debug "\n*\n*\n" + depstr

		#make an array of lines, where each line is a complete 
		#"<target>: <dep1> <dep2>" sequence
		deplines = depstr.gsub("\\\n", " ").split("\n")

		#split each of these lines into an array of tokens, 
		#yielding a 2-d token array
		tokens = deplines.map {|dl| dl.split(" ")}

		#drop the colon on the first element of each token line, 
		#it is <targetfile>:
		tokens.each {|ts| ts[0] = ts[0].chop()} 

		#find the token line that starts with the target file we want
		depfiles = Set.new() 
		tokens.each do |tokenline|
			cand_target = tokenline.shift()
			#debug "cand: #{cand_target}"
			#debug "target: #{target_file}"
			if(target_file == cand_target)
				if(@useByteImpls && (target_file[-3,3] == 'cmo'))
					implsline = tokenline.map {|cmifn| changeExt(cmifn, 'cmo')}
					implsline.delete_if {|cmofn| cmofn == target_file}
					depfiles.merge implsline
				end
				depfiles.merge(tokenline)
			end
		end
		expandedSet = depfiles.map {|fn| File.expand_path(fn)}
		#debug "ImmediateDeps:"
		#debug setString(expandedSet)
		return expandedSet
	end

	def invertDependencies(dependencyHash)
		invertHash = Hash.new()
		dependencyHash.each do |target, depSet|
			#debug "   INVERTING: #{target}"
			depSet.each do |dep|
				if(not invertHash.has_key?(dep))
					invertHash[dep] = Set.new()
				end
				#debug "      #{dep}XXX"
				invertHash[dep].add(target)
				#debug "      " + setString(invertHash[dep])
			end
		end
		return invertHash
	end

	#a target is stale if:
	# 1)the source file is newer than the target file
	# 2)the target depends on a target that is stale
	# 3)the target is older than a target it depends on, implying the
	#   depended on target was recompiled in a previous call to obake
	#   that did not recompile the current target
	def findStaleTargets(neededByHash, dependencyHash, leafTargets)
		staleSet = Set.new()
		visitedSet = Set.new()

		pendingTargets = Array.new()
		pendingTargets.concat(leafTargets.to_a())

		#search over the dependency graph starting at the leaves
		until (pendingTargets.empty?())
			target = pendingTargets.pop()
			visitedSet.add(target)
			unless (staleSet.include?(target))

				#test if target is older than it's source
				src = targetToSource target #target in srcDir
				build_target = toBuildDirFile(target)
				staleFromSource = isStale?(build_target, [src])

				#debug "\n\nTarget: \'#{(build_target)}\'"
				if (not staleFromSource)
					#test if target is older than targets it depends on
					deps = dependencyHash[target]
					dep_destinations = deps.map {|dep| toBuildDirFile(dep)}
					staleFromDep = isStale?(build_target, dep_destinations)
					#if(staleFromDep)
						#debug "Target mtime: #{File.mtime(build_target)}"
						#debug "One of these caused stale:"
						#dep_destinations.each do |build_dep|
						#	debug "#{build_dep}:: #{File.mtime(build_dep)}\n"
						#end
					#end
				end
				if(staleFromSource || staleFromDep)
					#debug "Staleness: src: \'#{staleFromSource.to_s}\'"
					#debug "Staleness: dep: \'#{staleFromDep.to_s}\'"
					#its stale. add it and all it's dependents to staleSet
					#debug "Staleness: adding: \'#{target}\'"
					staleSet.add(target)
					pendingStales = Array.new()
					pendingStales.concat(neededByHash[target].to_a())
					until(pendingStales.empty?())
						stale_target = pendingStales.pop()
						staleSet.add(stale_target)
						debug "Staleness: adding child: \'#{stale_target}\'"
						pendingStales.concat(neededByHash[stale_target].to_a)
					end
				else
					#it's not stale. add it's dependents to the pendingTargets
					#queue to be tested
					neededByHash[target].each do |child|
						if(not visitedSet.include?(child))
							pendingTargets << child
						end
					end
				end
			end
		end
		return staleSet
	end

	#compiles all stale sources in an order that ensures uptodate dependencies
	def compileSources(ordering, staleSet)
		ordering.each do |target|
			if(staleSet.include?(target))
				compileSourceOfTarget(target)
			end
		end

	end

	#returns an ordering (array) where every member is listed before all
	#other members that are "needed by it" as defined by the input 
	#filename -> dependents hash. the leafSet are those filenames that
	#don't need anything
	def findOrdering(neededByHash, leafSet)
		#this is the stack used to do a DFS
		pendingStack = Array.new()

		#for each target, this hash will contain an array of it's dependents
		#that have not yet been visited. The value will be initialized to
		#the values in neededByHash the first time a target node is visited,
		#and then decremented one by one as the graph is traversed
		remainingChildrenHash = Hash.new()

		def copySetToArray(st)
			newArr = []
			st.each {|vl| newArr.push(vl)}
			return newArr
		end

		pendingStack.concat(leafSet.to_a())
		pendingStack.each do |trg| 
			childrenSet = neededByHash[trg]
			childrenArr = copySetToArray(childrenSet)
			remainingChildrenHash[trg] = childrenArr
		end

		#the output ordering, where every filename is listed after all files
		#it depends on
		ordering = Array.new()

		until(pendingStack.empty?)
			#debug "\n\nfindOrdering:pendingStack: #{arrayString(pendingStack)}"
			nextTarget = pendingStack.last()
			#debug "findOrdering:Visiting: #{nextTarget}"
			if(remainingChildrenHash[nextTarget].empty?)
				pendingStack.pop()
				ordering.unshift(nextTarget)
			else
				nextChild = remainingChildrenHash[nextTarget].pop()
				unless (remainingChildrenHash.has_key?(nextChild))
					nextChildsChildrenSet = neededByHash[nextChild]
					nccArr = copySetToArray(nextChildsChildrenSet)
					remainingChildrenHash[nextChild] = nccArr
					pendingStack.push(nextChild)
				end
			end
		end
		return ordering
	
	end

	#ocaml tools often use a series of directories with "-I" before each as 
	#commandline options. this makes an option substring out of the input dirnames
	def makeIncludesString (dirnames) 
		str = ""
		dirnames.each do |dirname|
			str += " -I " + dirname
		end
		return str
	end

#	def makeLibrariesString()
#		case @compiler
#			when @@byteCodeCompiler
#				lib_ext = '.cma'
#			when @@machineCodeCompiler
#				lib_ext = '.cmxa'
#		end
#		str = ""
#		@libraries.each do |lb|
#			str += " " + lb + lib_ext
#		end
#		return str
#	end
#	
	def makeLibsStr(libsStrArray)
		str = ""
		unless libsStrArray.nil?
			libsStrArray.each {|lib| str += lib + ","}
			str.chop!() if (libsStrArray != 0)
		end	
		return str
	end



	#takes a filename w/ full path and changes it to the build directory 
	def toBuildDirFile(filename)
		return File.join(@buildDestination, File.basename(filename))
	end

	#takes a filename w/ full path and changes it to the bin directory 
	def toBinDirFile(filename)
		return File.join(@binDestination, File.basename(filename))
	end
	#figure out what file needs to be compiled to produce the 
	#input filename, then move the generated file(s) to the build dir
	def compileSourceOfTarget(target)
		incstr = @includesString	
		src_file = targetToSource(target)
		target_ext = File.extname target
		source_ext = File.extname src_file
		artifacts = [target]
		debug "COMP: Target: \'#{target}\'"
		#debug "COMP: Source: \'#{src_file}\'"
		#expected artifacts
		if (target_ext == '.cmx') 
			artifacts.push(changeExt(target, '.o'))
		end
		if (source_ext == '.ml')
			unless(File.exist?(changeExt(target, '.mli')))
				artifacts.push(changeExt(target, '.cmi'))
			end
		end

		case @compiler
			when @@byteCodeCompiler 
				cmd = "ocamlfind ocamlc -g -c "
				cmd += "-package #{@libsStr} " unless(@libsStr == "") 
				cmd += "#{incstr} #{src_file}"
			when @@machineCodeCompiler
				cmd = "ocamlfind ocamlopt -c "
				cmd += "-p " if (@profilingEnabled)
				cmd += "-package #{@libsStr} " unless(@libsStr == "") 
				cmd += "#{incstr} #{src_file}"
			else 
				puts "ERROR couldn't compile to file: " + target
		end
		debug cmd
		`#{cmd}`
		if($? == 0) #the compiler had no error
			artifacts.each do |artfile|
				#debug "compiler ran"
				builddest = toBuildDirFile(artfile)
				#debug "\t builddirtarget: " + builddest
				#debug "\t target: " + artfile 
				#if(not File.exists?(artfile)) then exit end
				unless (artfile == builddest)
					File.rename(artfile, builddest)
				end
			end
		end
	end

	def buildExecs (binSourceSet, mainOrdering, dependencyHash, staleSet)
		#remove any that aren't stale, as indicated by it's .cmo/.cmx being
		#not stale
		binSourceSet.each do |binSource|
			comp_target = sourceToTarget(binSource)
			unless staleSet.include?(comp_target)
				binSourceSet.delete(binSource)
			end
		end

		numExecs = binSourceSet.size()

		#unlinked_targets => bit mask over mainOrdering array
		orderingMasksHash = Hash.new()

		#populating orderingMasksHash
		if(numExecs == 1)
			#if only one, assume it was the only file being baked and link
			#everything in the ordering into executable
			bits = Array.new(mainOrdering.size(), true)
			dependencyHash.each_key {|k| orderingMasksHash[k] = bits}
		else
			#else we must figure out exactly those files needed by the 
			#linker for each exec, and create a bitMask
			binSourceSet.each do |binSource|
				deps = Set.new()
				pendingStack = Array.new()
				unlinked_target = sourceToTarget(binSource) #.cmo or .cmx in srcDir
				pendingStack.push(unlinked_target)
				until(pendingStack.empty?())
					next_target = pendingStack.pop()
					children = dependencyHash[next_target]
					children.each do |child| 
						deps.add(child)
						pendingStack.push(child)
					end
				end
				bits = Array.new(mainOrdering.size())
				mainOrdering.each_index do |idx|
					bits[idx] = (deps.include?(mainOrdering[idx]))
				end
				orderingMasksHash[unlinked_target] = bits
			end
		end
		#libString = makeLibrariesString()
		#.cmi files shouldn't be included in the linking
		cmiMask = Array.new(mainOrdering.size())
		mainOrdering.each_index do |idx|
			cmiMask[idx] = (File.extname(mainOrdering[idx]) == '.cmi')
		end
		binSourceSet.each do |binSource|
			srcDir_target = sourceToTarget(binSource) #.cmo/.cmx in srcDir
			buildDir_target = toBuildDirFile(srcDir_target) #.cmo/.cmx in buildDir
			linked_target = toBinDirFile(changeExt(binSource, '.bin'))
			#link_str = libString
			link_str = ""
			depMask = orderingMasksHash[srcDir_target]
			mainOrdering.each_index do |idx|
				if(depMask[idx] && (not cmiMask[idx]))
					link_str += " " + toBuildDirFile(mainOrdering[idx])
				end
			end
			case @compiler
				when @@byteCodeCompiler
					cmd = "ocamlfind ocamlc -g "
					cmd += "-linkpkg -package #{@libsStr} " unless(@libsStr == "") 
					cmd += "-o #{linked_target} #{link_str}"
					debug cmd
					`#{cmd}`
				when @@machineCodeCompiler
					cmd = "ocamlfind ocamlopt "
					cmd += "-linkpkg -package #{@libsStr} " unless(@libsStr == "") 
					cmd += "-p " if (@profilingEnabled)
					cmd += "-o #{linked_target} #{link_str}"
					debug cmd
					#debug "HI 1"
					`#{cmd}`
					#debug "HI 2"
				else
					puts "ERROR linking"
			end
		end
	end

	def runParsers()
		@parserFiles.each do |mlyfile|
			#debug "making parser: " + mlyfile
			targetmli = changeExt(mlyfile, 'mli')
			targetml = changeExt(mlyfile, 'ml')
			if isSourceStale?(mlyfile, 'ml')
				debug `ocamlyacc #{mlyfile}` 
				File.rename(targetmli, toBuildDirFile(targetmli))
				File.rename(targetml, toBuildDirFile(targetml))
			end
		end
	end

	def runLexers()
		@lexerFiles.each do |mllfile|
			#debug "making lexer: " + mllfile
			targetml = changeExt(mllfile, 'ml')
			if isSourceStale?(mllfile, 'ml')
				debug `ocamllex #{mllfile}`
				File.rename(targetml, toBuildDirFile(targetml))
			end
		end
	end

	#returns true if file is older than any one of the old_files in comparison
	def isStale?(file, old_files)
		return true unless File.exist?(file)
		new_time = File.mtime(file)
		old_files.each do |old|
			if File.exist?(old)
				#debug "New Time: #{new_time}"
				#debug "Old Time: #{File.mtime(old)}"
				return true if new_time < File.mtime(old)
			end
		end
		return false
	end

	#returns true if the sourcefile is newer than the source file with the same
	#basename, but extension taretext, in $builddir
	def isSourceStale?(sourcefile, targetext)
		targetfile = toBuildDirFile(changeExt(sourcefile, targetext))
		return (isStale?(targetfile, [sourcefile]))
	end


end



#change the extension on a string representing a filename
def changeExt(filename, newext) 
	useme = filename.dup
	return useme if ['.', '..'].include? filename
	if newext != ''
		newext = (newext =~ /^\./) ? newext : ("." + newext)
	end
	useme.sub!(%r(([^/\\])\.[^./\\]*$)) { $1 + newext } || useme + newext
end

$setIndent1 = "  "
$setIndent2 = "      "

def hashString(hsh)
	str = "\{"
	hsh.each do |ky, vl|
		str += "\n#{$setIndent1}#{ky} => #{vl} ,"
	end
	str.chop!()
	str += "\n\}"
	return str
end

def arrayString(arr)
	str = "\["
	arr.each do |vl|
		str += "\n#{$setIndent1}#{vl},"
	end
	str.chop!()
	str += "\n\]"
	return str
end


def setString(st)
	str = "\( "
	st.each do |vl|
		str += "\n#{$setIndent1}#{vl} ,"
	end
	str.chop!()
	str += "\n\)"
	return str
end

def setHashString(hsh)
	str = "\{\n"
	hsh.each do |ky, vl|
		stringOfSet = "\("
		vl.each do |v|
			stringOfSet += "\n#{$setIndent2}#{v} ,"
		end
		stringOfSet.chop!()
		stringOfSet += "\n#{$setIndent2}\)"
		str += "#{$setIndent1}#{ky} => #{stringOfSet} ,\n"
	end
	str.chop!().chop!()
	str += "\n\}"
	return str
end




if __FILE__ == $0
	runDef = OBaker.getConfigDef()
	runDef.deduceOptions(ARGV)
	if(not runDef.getArgumentHash().nil?)
		if(runDef.getArgumentHash()[:verbosity] == :verbose)
			$DEBUG = true
		end
		debug "\nFiles from commandline:\n"
		debug arrayString(runDef.getOpenList())
		debug ""
		baker = OBaker.new(runDef)
		baker.bake()
	end
	
end
